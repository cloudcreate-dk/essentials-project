/*
 * Copyright 2021-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dk.cloudcreate.essentials.components.eventsourced.eventstore.postgresql.persistence.table_per_aggregate_type;

import dk.cloudcreate.essentials.components.eventsourced.eventstore.postgresql.eventstream.*;
import dk.cloudcreate.essentials.components.eventsourced.eventstore.postgresql.persistence.*;
import dk.cloudcreate.essentials.components.eventsourced.eventstore.postgresql.serializer.*;
import dk.cloudcreate.essentials.components.eventsourced.eventstore.postgresql.serializer.json.*;
import dk.cloudcreate.essentials.components.foundation.postgresql.PostgresqlUtil;
import dk.cloudcreate.essentials.components.foundation.types.*;

import java.util.function.Function;

import static dk.cloudcreate.essentials.shared.FailFast.requireNonNull;
import static dk.cloudcreate.essentials.shared.MessageFormatter.msg;

/**
 * Helper Factory for creating {@link SeparateTablePerAggregateEventStreamConfiguration}
 * with a shared/common configuration that's compatible with the {@link SeparateTablePerAggregateTypePersistenceStrategy}<br>
 * <br>
 * <u><b>Security</b></u><br>
 * This factory produces {@link SeparateTablePerAggregateEventStreamConfiguration} instances with values provided to the factory methods.<br>
 * Attention must be paid to the following:<br>
 * <u>AggregateType</u><br>
 * The {@link AggregateType}'s value will be converted to a table name, or part of a table name, and thereafter directly be used in constructing SQL statements through string concatenation, which exposes that component to SQL injection attacks.<br>
 * <br>
 * It is the responsibility of the user of those components to sanitize the {@link AggregateType}'s value
 * to ensure the security of all the SQL statements generated by this component.<br>
 * <br>
 * Components may call the {@code PostgresqlUtil#checkIsValidTableOrColumnName(String)} method to validate the table name as a first line of defense.<br>
 * The {@code PostgresqlUtil#checkIsValidTableOrColumnName(String)} provides an initial layer of defense against SQL injection by applying naming conventions intended to reduce the risk of malicious input.<br>
 * However, Essentials components as well as {@code PostgresqlUtil#checkIsValidTableOrColumnName(String)} does not offer exhaustive protection, nor does it assure the complete security of the resulting SQL against SQL injection threats.<br>
 * <b>The responsibility for implementing protective measures against SQL Injection lies exclusively with the users/developers using the Essentials components and its supporting classes.</b><br>
 * Users must ensure thorough sanitization and validation of API input parameters,  column, table, and index names.<br>
 * Insufficient attention to these practices may leave the application vulnerable to SQL injection, potentially endangering the security and integrity of the database.<br>
 *
 * <br>
 * It is highly recommended that the {@link AggregateType}'s value is only derived from a controlled and trusted source.<br>
 * To mitigate the risk of SQL injection attacks, external or untrusted inputs should never directly provide the {@link AggregateType}'s value.<br>
 * <b>Failure to adequately sanitize and validate this value could expose the application to SQL injection<br>
 * <br>
 * <u>SeparateTablePerAggregateEventStreamConfiguration#eventStreamTableName</u><br>
 * The {@link SeparateTablePerAggregateEventStreamConfiguration#eventStreamTableName} defines the Postgresql table name where {@link PersistedEvent}'s related to {@link SeparateTablePerAggregateEventStreamConfiguration#aggregateType} are stored<br>
 * The {@code eventStreamTableName}'s value will be directly used in constructing SQL statements (in components using the {@link SeparateTablePerAggregateEventStreamConfiguration},
 * such as {@link SeparateTablePerAggregateTypePersistenceStrategy}) through string concatenation, which exposes the component to SQL injection attacks.<br>
 * <br>
 * <blockquote>It is the responsibility of the user of this component to sanitize the {@code eventStreamTableName}'s value
 * to ensure the security of all the SQL statements generated by components using the {@link SeparateTablePerAggregateEventStreamConfiguration}, such as the {@link SeparateTablePerAggregateTypePersistenceStrategy}.
 * </blockquote>
 * The {@link SeparateTablePerAggregateEventStreamConfiguration} component will
 * call the {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} method to validate the table name as a first line of defense.<br>
 * The {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} provides an initial layer of defense against SQL injection by applying naming conventions intended to reduce the risk of malicious input.<br>
 * However, Essentials components as well as {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} does not offer exhaustive protection, nor does it assure the complete security of the resulting SQL against SQL injection threats.<br>
 * <b>The responsibility for implementing protective measures against SQL Injection lies exclusively with the users/developers using the Essentials components and its supporting classes.</b><br>
 * Users must ensure thorough sanitization and validation of API input parameters,  column, table, and index names.<br>
 * Insufficient attention to these practices may leave the application vulnerable to SQL injection, potentially endangering the security and integrity of the database.<br>
 * <br>
 * It is highly recommended that the {@code eventStreamTableName}'s value is only derived from a controlled and trusted source.<br>
 * To mitigate the risk of SQL injection attacks, external or untrusted inputs should never directly provide the {@code eventStreamTableName}'s value.<br>
 * <b>Failure to adequately sanitize and validate this value could expose the application to SQL injection
 * vulnerabilities, compromising the security and integrity of the database.</b><br>
 * <br>
 * <u>SeparateTablePerAggregateEventStreamConfiguration#eventStreamTableColumnNames</u><br>
 * The {@link SeparateTablePerAggregateEventStreamConfiguration#eventStreamTableColumnNames} defines the columns names used for persisting AggregateEventStreams related to a specific {@link AggregateType}<br>
 * <br>
 * <b>All the column names provided</b> will be directly used in constructing SQL statements
 * through string concatenation, in components such as {@link SeparateTablePerAggregateTypePersistenceStrategy}, which exposes those components to SQL injection attacks.<br>
 * <br>
 * <blockquote>It is the responsibility of the user of this component to sanitize <b>all the column names provided</b>
 * to ensure the security of all the SQL statements generated by this component.</blockquote><br>
 * The {@link SeparateTablePerAggregateEventStreamConfiguration} component will
 * call the {@link EventStreamTableColumnNames#validate()} method, which uses {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)}, to validate the column names provided as a first line of defense.<br>
 * The {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} provides an initial layer of defense against SQL injection by applying naming conventions intended to reduce the risk of malicious input.<br>
 * However, {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} does not offer exhaustive protection, nor does it assure the complete security of the resulting SQL against SQL injection threats.<br>
 * <b>The responsibility for implementing protective measures against SQL Injection lies exclusively with the users/developers using the Essentials components and its supporting classes.</b><br>
 * Users must ensure thorough sanitization and validation of API input parameters,  column, table, and index names.<br>
 * Insufficient attention to these practices may leave the application vulnerable to SQL injection, potentially endangering the security and integrity of the database.<br>
 * <br>
 * It is highly recommended that <b>all the column names provided</b> are derived from a controlled and trusted source.<br>
 * To mitigate the risk of SQL injection attacks, external or untrusted inputs should never directly provide the column name values.<br>
 * <b>Failure to adequately sanitize and validate these values could expose the application to SQL injection
 * vulnerabilities, compromising the security and integrity of the database.</b><br>
 */
public final class SeparateTablePerAggregateTypeEventStreamConfigurationFactory implements AggregateEventStreamConfigurationFactory<SeparateTablePerAggregateEventStreamConfiguration> {
    /**
     * The Function that resolves the unique name of the Postgresql table name where ONLY {@link PersistedEvent}'s related to supplied {@link AggregateType} will be stored stored<br>
     * The {@code eventStreamTableName}'s value resolved by this function will be directly used in constructing SQL statements (in components using the {@link SeparateTablePerAggregateEventStreamConfiguration},
     * such as {@link SeparateTablePerAggregateTypePersistenceStrategy}) through string concatenation, which exposes the component to SQL injection attacks.<br>
     * <br>
     * <strong>Security Note:</strong><br>
     * It is the responsibility of the user of this component to sanitize the resolved {@code eventStreamTableName}'s value
     * to ensure the security of all the SQL statements generated by components using the {@link SeparateTablePerAggregateEventStreamConfiguration}, such as {@link SeparateTablePerAggregateTypePersistenceStrategy}.
     * The {@link SeparateTablePerAggregateEventStreamConfiguration} component will
     * call the {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} method to validate the table name as a first line of defense.<br>
     * However, {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} does not offer exhaustive protection, nor does it assure the complete security of the resulting SQL against SQL injection threats.<br>
     * <b>The responsibility for implementing protective measures against SQL Injection lies exclusively with the users/developers using the Essentials components and its supporting classes.</b><br>
     * Users must ensure thorough sanitization and validation of API input parameters,  column, table, and index names.<br>
     * Insufficient attention to these practices may leave the application vulnerable to SQL injection, potentially endangering the security and integrity of the database.<br>
     * <br>
     * It is highly recommended that the {@code eventStreamTableName}'s value is only derived from a controlled and trusted source.<br>
     * To mitigate the risk of SQL injection attacks, external or untrusted inputs should never directly provide the {@code eventStreamTableName}'s value.<br>
     * <b>Failure to adequately sanitize and validate this value could expose the application to SQL injection
     * vulnerabilities, compromising the security and integrity of the database.</b><br>
     */
    public final Function<AggregateType, String> resolveEventStreamTableName;
    /**
     * The names of the event stream columns - The actual implementation must be compatible with the chosen {@link AggregateEventStreamPersistenceStrategy}
     */
    public final EventStreamTableColumnNames     eventStreamTableColumnNames;
    /**
     * The SQL fetch size for Queries
     */
    public final int                             queryFetchSize;
    /**
     * The {@link JSONEventSerializer} used to serialize and deserialize {@link PersistedEvent#event()} and {@link PersistedEvent#metaData()}
     */
    public final JSONEventSerializer             jsonSerializer;
    /**
     * The SQL Column type for the Aggregate Id<br>
     * We've deliberately split {@link AggregateIdSerializer} and {@link #aggregateIdColumnType}
     * as it's possible to use e.g. a {@link AggregateIdSerializer.StringIdSerializer} or {@link AggregateIdSerializer.CharSequenceTypeIdSerializer}
     * which purely contains {@link java.util.UUID} string values, in which case it should be possible to
     * map these to {@link IdentifierColumnType#UUID}
     */
    public final IdentifierColumnType            aggregateIdColumnType;
    /**
     * The SQL column type for the {@link EventId} column
     */
    public final IdentifierColumnType            eventIdColumnType;
    /**
     * The SQL column type for the {@link CorrelationId} column
     */
    public final IdentifierColumnType            correlationIdColumnType;
    /**
     * The SQL column type for the {@link JSONEventSerializer} serialized Event
     */
    public final JSONColumnType                  eventJsonColumnType;
    /**
     * The SQL column type for the {@link JSONEventSerializer} serialized {@link EventMetaData}
     */
    public final JSONColumnType                  eventMetadataJsonColumnType;
    /**
     * The serializer for the {@link Tenant} value (or {@link TenantSerializer.TenantIdSerializer.NoSupportForMultiTenancySerializer} if it's a single tenant application)
     */
    public final TenantSerializer                tenantSerializer;

    /**
     * @param resolveEventStreamTableName The Function that resolves the unique name of the Postgresql table name where ONLY {@link PersistedEvent}'s related to supplied {@link AggregateType} will be stored stored<br>
     *                                    <b>Note: The table name provided will automatically be converted to <u>lower case</u></b><br>
     *                                    <br>
     *                                    <strong>Note:</strong><br>
     *                                    The {@code eventStreamTableName}'s value resolved by this function will be directly used in constructing SQL statements (in components using the {@link SeparateTablePerAggregateEventStreamConfiguration},
     *                                    such as {@link SeparateTablePerAggregateTypePersistenceStrategy}) through string concatenation, which exposes the component to SQL injection attacks.<br>
     *                                    <br>
     *                                    <strong>Security Note:</strong><br>
     *                                    It is the responsibility of the user of this component to sanitize the resolved {@code eventStreamTableName}'s value
     *                                    to ensure the security of all the SQL statements generated by components using the {@link SeparateTablePerAggregateEventStreamConfiguration}, such as {@link SeparateTablePerAggregateTypePersistenceStrategy}.
     *                                    The {@link SeparateTablePerAggregateEventStreamConfiguration} component will
     *                                    call the {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} method to validate the table name as a first line of defense.<br>
     *                                    However, {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} does not offer exhaustive protection, nor does it assure the complete security of the resulting SQL against SQL injection threats.<br>
     *                                    <b>The responsibility for implementing protective measures against SQL Injection lies exclusively with the users/developers using the Essentials components and its supporting classes.</b><br>
     *                                    Users must ensure thorough sanitization and validation of API input parameters,  column, table, and index names.<br>
     *                                    Insufficient attention to these practices may leave the application vulnerable to SQL injection, potentially endangering the security and integrity of the database.<br>
     *                                    <br>
     *                                    It is highly recommended that the {@code eventStreamTableName}'s value is only derived from a controlled and trusted source.<br>
     *                                    To mitigate the risk of SQL injection attacks, external or untrusted inputs should never directly provide the {@code eventStreamTableName}'s value.<br>
     *                                    <b>Failure to adequately sanitize and validate this value could expose the application to SQL injection
     *                                    vulnerabilities, compromising the security and integrity of the database.</b><br>
     * @param eventStreamTableColumnNames Defines the names of the eventStreamTableColumnNames - The actual implementation must be compatible with the chosen {@link AggregateEventStreamPersistenceStrategy}<br>
     *                                    <br>
     *                                    <u><b>Security</b></u><br>
     *                                    <br>
     *                                    <b>All the column names provided</b> will be directly used in constructing SQL statements
     *                                    through string concatenation, in components such as {@link SeparateTablePerAggregateTypePersistenceStrategy}, which exposes those components to SQL injection attacks.<br>
     *                                    <br>
     *                                    It is the responsibility of the user of this component to sanitize <b>all the column names provided</b>
     *                                    to ensure the security of all the SQL statements generated by this component. The {@link SeparateTablePerAggregateTypeEventStreamConfigurationFactory} component will
     *                                    call the {@link EventStreamTableColumnNames#validate()} method, which uses {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)}, to validate the column names provided as a first line of defense.<br>
     *                                    The {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} provides an initial layer of defense against SQL injection by applying naming conventions intended to reduce the risk of malicious input.<br>
     *                                    However, {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} does not offer exhaustive protection, nor does it assure the complete security of the resulting SQL against SQL injection threats.<br>
     *                                    <b>The responsibility for implementing protective measures against SQL Injection lies exclusively with the users/developers using the Essentials components and its supporting classes.</b><br>
     *                                    Users must ensure thorough sanitization and validation of API input parameters,  column, table, and index names.<br>
     *                                    Insufficient attention to these practices may leave the application vulnerable to SQL injection, potentially endangering the security and integrity of the database.<br>
     *
     *                                    <br>
     *                                    It is highly recommended that <b>all the column names provided</b> are derived from a controlled and trusted source.<br>
     *                                    To mitigate the risk of SQL injection attacks, external or untrusted inputs should never directly provide the column name values.<br>
     *                                    <br>
     *                                    <b>Failure to adequately sanitize and validate this value could expose the application to SQL injection
     *                                    vulnerabilities, compromising the security and integrity of the database.</b>
     * @param queryFetchSize              The SQL fetch size for Queries
     * @param jsonSerializer              The {@link JSONEventSerializer} used to serialize and deserialize {@link PersistedEvent#event()} and {@link PersistedEvent#metaData()}
     * @param aggregateIdColumnType       The SQL Column type for the Aggregate Id<br>
     *                                    We've deliberately split {@link AggregateIdSerializer} and {@link #aggregateIdColumnType}
     *                                    as it's possible to use e.g. a {@link AggregateIdSerializer.StringIdSerializer} or {@link AggregateIdSerializer.CharSequenceTypeIdSerializer}
     *                                    which purely contains {@link java.util.UUID} string values, in which case it should be possible to
     *                                    map these to {@link IdentifierColumnType#UUID}
     * @param eventIdColumnType           The SQL column type for the {@link dk.cloudcreate.essentials.components.foundation.types.EventId} column
     * @param correlationIdColumnType     The SQL column type for the {@link dk.cloudcreate.essentials.components.foundation.types.CorrelationId} column
     * @param eventJsonColumnType         The SQL column type for the {@link JSONEventSerializer} serialized Event
     * @param eventMetadataJsonColumnType The SQL column type for the {@link JSONEventSerializer} serialized {@link dk.cloudcreate.essentials.components.eventsourced.eventstore.postgresql.persistence.EventMetaData}
     * @param tenantSerializer            The serializer for the {@link Tenant} value (or {@link dk.cloudcreate.essentials.components.eventsourced.eventstore.postgresql.serializer.TenantSerializer.NoSupportForMultiTenancySerializer} if it's a single tenant application)
     */
    public SeparateTablePerAggregateTypeEventStreamConfigurationFactory(Function<AggregateType, String> resolveEventStreamTableName,
                                                                        EventStreamTableColumnNames eventStreamTableColumnNames,
                                                                        int queryFetchSize,
                                                                        JSONEventSerializer jsonSerializer,
                                                                        IdentifierColumnType aggregateIdColumnType,
                                                                        IdentifierColumnType eventIdColumnType,
                                                                        IdentifierColumnType correlationIdColumnType,
                                                                        JSONColumnType eventJsonColumnType,
                                                                        JSONColumnType eventMetadataJsonColumnType,
                                                                        TenantSerializer<?> tenantSerializer) {
        this.resolveEventStreamTableName = requireNonNull(resolveEventStreamTableName, "No resolveEventStreamTableName provided");
        this.eventStreamTableColumnNames = requireNonNull(eventStreamTableColumnNames, "No eventStreamTableColumnNames provided");
        this.queryFetchSize = queryFetchSize;
        this.jsonSerializer = requireNonNull(jsonSerializer, "No jsonSerializer provided");
        this.aggregateIdColumnType = requireNonNull(aggregateIdColumnType, "No aggregateIdColumnType provided");
        this.eventIdColumnType = requireNonNull(eventIdColumnType, "No eventIdColumnType provided");
        this.correlationIdColumnType = requireNonNull(correlationIdColumnType, "No correlationIdColumnType provided");
        this.eventJsonColumnType = requireNonNull(eventJsonColumnType, "No eventJsonColumnType provided");
        this.eventMetadataJsonColumnType = requireNonNull(eventMetadataJsonColumnType, "No eventMetadataJsonColumnType provided");
        this.tenantSerializer = requireNonNull(tenantSerializer, "No tenantSerializer provided");

        this.eventStreamTableColumnNames.validate();
    }

    /**
     * Create an event stream configuration factory using common configuration for all produced {@link SeparateTablePerAggregateEventStreamConfiguration}'s:<br>
     * {@link SeparateTablePerAggregateEventStreamConfiguration#eventStreamTableName} = {@link AggregateType#toString()} + "_events<br>
     * {@link SeparateTablePerAggregateEventStreamConfiguration#eventStreamTableColumnNames} = {@link EventStreamTableColumnNames#defaultColumnNames()}<br>
     * {@link SeparateTablePerAggregateEventStreamConfiguration#queryFetchSize} = 100<br>
     * {@link SeparateTablePerAggregateEventStreamConfiguration#tenantSerializer} = {@link TenantSerializer.NoSupportForMultiTenancySerializer}<br>
     * {@link SeparateTablePerAggregateEventStreamConfiguration#jsonSerializer} = {@link JacksonJSONEventSerializer}<br>
     *
     * @param jsonSerializer                            The {@link JSONEventSerializer}
     * @param identifierColumnTypeUsedForAllIdentifiers The SQL Column type used for all identifier columns (aggregate id, event id, correlation id, etc.)
     * @param jsonColumnTypeUsedForAllJSONColumns       The SQL JSON column type used for all JSON columns (Event and {@link EventMetaData})
     * @return the event stream configuration factory
     */
    public static SeparateTablePerAggregateTypeEventStreamConfigurationFactory standardSingleTenantConfiguration(JSONEventSerializer jsonSerializer,
                                                                                                                 IdentifierColumnType identifierColumnTypeUsedForAllIdentifiers,
                                                                                                                 JSONColumnType jsonColumnTypeUsedForAllJSONColumns) {
        return standardConfiguration(jsonSerializer,
                                     identifierColumnTypeUsedForAllIdentifiers,
                                     jsonColumnTypeUsedForAllJSONColumns,
                                     new TenantSerializer.NoSupportForMultiTenancySerializer());
    }

    /**
     * Create an event stream configuration factory using common configuration for all produced {@link SeparateTablePerAggregateEventStreamConfiguration}'s:<br>
     * {@link SeparateTablePerAggregateEventStreamConfiguration#queryFetchSize} = 100<br>
     * {@link SeparateTablePerAggregateEventStreamConfiguration#tenantSerializer} = {@link TenantSerializer.NoSupportForMultiTenancySerializer}<br>
     * {@link SeparateTablePerAggregateEventStreamConfiguration#jsonSerializer} = {@link JacksonJSONEventSerializer}<br>
     *
     * @param resolveEventStreamTableName               The Function that resolves the unique name of the Postgresql table name where ONLY {@link PersistedEvent}'s related to supplied {@link AggregateType} will be stored stored<br>
     *                                                  <b>Note: The table name provided will automatically be converted to <u>lower case</u></b><br>
     *                                                  <br>
     *                                                  <strong>Note:</strong><br>
     *                                                  The {@code eventStreamTableName}'s value resolved by this function will be directly used in constructing SQL statements (in components using the {@link SeparateTablePerAggregateEventStreamConfiguration},
     *                                                  such as {@link SeparateTablePerAggregateTypePersistenceStrategy}) through string concatenation, which exposes the component to SQL injection attacks.<br>
     *                                                  <br>
     *                                                  <strong>Security Note:</strong><br>
     *                                                  It is the responsibility of the user of this component to sanitize the resolved {@code eventStreamTableName}'s value
     *                                                  to ensure the security of all the SQL statements generated by components using the {@link SeparateTablePerAggregateEventStreamConfiguration}, such as {@link SeparateTablePerAggregateTypePersistenceStrategy}.
     *                                                  The {@link SeparateTablePerAggregateEventStreamConfiguration} component will
     *                                                  call the {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} method to validate the table name as a first line of defense.<br>
     *                                                  However, {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} does not offer exhaustive protection, nor does it assure the complete security of the resulting SQL against SQL injection threats.<br>
     *                                                  <b>The responsibility for implementing protective measures against SQL Injection lies exclusively with the users/developers using the Essentials components and its supporting classes.</b><br>
     *                                                  Users must ensure thorough sanitization and validation of API input parameters,  column, table, and index names.<br>
     *                                                  Insufficient attention to these practices may leave the application vulnerable to SQL injection, potentially endangering the security and integrity of the database.<br>
     *                                                  <br>
     *                                                  It is highly recommended that the {@code eventStreamTableName}'s value is only derived from a controlled and trusted source.<br>
     *                                                  To mitigate the risk of SQL injection attacks, external or untrusted inputs should never directly provide the {@code eventStreamTableName}'s value.<br>
     *                                                  <b>Failure to adequately sanitize and validate this value could expose the application to SQL injection
     *                                                  vulnerabilities, compromising the security and integrity of the database.</b><br>
     * @param eventStreamTableColumnNames               Defines the names of the eventStreamTableColumnNames - The actual implementation must be compatible with the chosen {@link AggregateEventStreamPersistenceStrategy}<br>
     *                                                  <br>
     *                                                  <u><b>Security</b></u><br>
     *                                                  <br>
     *                                                  <b>All the column names provided</b> will be directly used in constructing SQL statements
     *                                                  through string concatenation, in components such as {@link SeparateTablePerAggregateTypePersistenceStrategy}, which exposes those components to SQL injection attacks.<br>
     *                                                  <br>
     *                                                  It is the responsibility of the user of this component to sanitize <b>all the column names provided</b>
     *                                                  to ensure the security of all the SQL statements generated by this component. The {@link SeparateTablePerAggregateEventStreamConfiguration} component will
     *                                                  call the {@link EventStreamTableColumnNames#validate()} method, which uses {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)}, to validate the column names provided as a first line of defense.<br>
     *                                                  The {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} provides an initial layer of defense against SQL injection by applying naming conventions intended to reduce the risk of malicious input.<br>
     *                                                  However, {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} does not offer exhaustive protection, nor does it assure the complete security of the resulting SQL against SQL injection threats.<br>
     *                                                  <b>The responsibility for implementing protective measures against SQL Injection lies exclusively with the users/developers using the Essentials components and its supporting classes.</b><br>
     *                                                  Users must ensure thorough sanitization and validation of API input parameters,  column, table, and index names.<br>
     *                                                  Insufficient attention to these practices may leave the application vulnerable to SQL injection, potentially endangering the security and integrity of the database.<br>
     *
     *                                                  <br>
     *                                                  It is highly recommended that <b>all the column names provided</b> are derived from a controlled and trusted source.<br>
     *                                                  To mitigate the risk of SQL injection attacks, external or untrusted inputs should never directly provide the column name values.<br>
     *                                                  <br>
     *                                                  <b>Failure to adequately sanitize and validate this value could expose the application to SQL injection
     *                                                  vulnerabilities, compromising the security and integrity of the database.</b>
     * @param jsonSerializer                            The {@link JSONEventSerializer}
     * @param identifierColumnTypeUsedForAllIdentifiers The SQL Column type used for all identifier columns (aggregate id, event id, correlation id, etc.)
     * @param jsonColumnTypeUsedForAllJSONColumns       The SQL JSON column type used for all JSON columns (Event and {@link EventMetaData})
     * @return the event stream configuration factory
     */
    public static SeparateTablePerAggregateTypeEventStreamConfigurationFactory standardSingleTenantConfiguration(Function<AggregateType, String> resolveEventStreamTableName,
                                                                                                                 EventStreamTableColumnNames eventStreamTableColumnNames,
                                                                                                                 JSONEventSerializer jsonSerializer,
                                                                                                                 IdentifierColumnType identifierColumnTypeUsedForAllIdentifiers,
                                                                                                                 JSONColumnType jsonColumnTypeUsedForAllJSONColumns) {
        return standardConfiguration(resolveEventStreamTableName,
                                     eventStreamTableColumnNames,
                                     jsonSerializer,
                                     identifierColumnTypeUsedForAllIdentifiers,
                                     jsonColumnTypeUsedForAllJSONColumns,
                                     new TenantSerializer.NoSupportForMultiTenancySerializer());
    }

    /**
     * Create an event stream configuration factory using common configuration for all produced {@link SeparateTablePerAggregateEventStreamConfiguration}'s:<br>
     * {@link SeparateTablePerAggregateEventStreamConfiguration#eventStreamTableName} = {@link AggregateType#toString()} + "_events<br>
     * {@link SeparateTablePerAggregateEventStreamConfiguration#eventStreamTableColumnNames} = {@link EventStreamTableColumnNames#defaultColumnNames()}<br>
     * {@link SeparateTablePerAggregateEventStreamConfiguration#queryFetchSize} = 100<br>
     * {@link SeparateTablePerAggregateEventStreamConfiguration#jsonSerializer} = {@link JacksonJSONEventSerializer}<br>
     *
     * @param jsonSerializer                            The {@link JSONEventSerializer}
     * @param identifierColumnTypeUsedForAllIdentifiers The SQL Column type used for all identifier columns (aggregate id, event id, correlation id, etc.)
     * @param jsonColumnTypeUsedForAllJSONColumns       The SQL JSON column type used for all JSON columns (Event and {@link EventMetaData})
     * @return the event stream configuration factory
     */
    public static SeparateTablePerAggregateTypeEventStreamConfigurationFactory standardConfiguration(JSONEventSerializer jsonSerializer,
                                                                                                     IdentifierColumnType identifierColumnTypeUsedForAllIdentifiers,
                                                                                                     JSONColumnType jsonColumnTypeUsedForAllJSONColumns,
                                                                                                     TenantSerializer<?> tenantSerializer) {
        return new SeparateTablePerAggregateTypeEventStreamConfigurationFactory(aggregateType -> aggregateType + "_events",
                                                                                EventStreamTableColumnNames.defaultColumnNames(),
                                                                                100,
                                                                                jsonSerializer,
                                                                                identifierColumnTypeUsedForAllIdentifiers,
                                                                                identifierColumnTypeUsedForAllIdentifiers,
                                                                                identifierColumnTypeUsedForAllIdentifiers,
                                                                                jsonColumnTypeUsedForAllJSONColumns,
                                                                                jsonColumnTypeUsedForAllJSONColumns,
                                                                                tenantSerializer);
    }

    /**
     * Create an event stream configuration factory using common configuration for all produced {@link SeparateTablePerAggregateEventStreamConfiguration}'s:<br>
     * {@link SeparateTablePerAggregateEventStreamConfiguration#queryFetchSize} = 100<br>
     * {@link SeparateTablePerAggregateEventStreamConfiguration#jsonSerializer} = {@link JacksonJSONEventSerializer}<br>
     *
     * @param resolveEventStreamTableName               The Function that resolves the unique name of the Postgresql table name where ONLY {@link PersistedEvent}'s related to supplied {@link AggregateType} will be stored stored<br>
     *                                                  <b>Note: The table name provided will automatically be converted to <u>lower case</u></b><br>
     *                                                  <br>
     *                                                  <strong>Note:</strong><br>
     *                                                  The {@code eventStreamTableName}'s value resolved by this function will be directly used in constructing SQL statements (in components using the {@link SeparateTablePerAggregateEventStreamConfiguration},
     *                                                  such as {@link SeparateTablePerAggregateTypePersistenceStrategy}) through string concatenation, which exposes the component to SQL injection attacks.<br>
     *                                                  <br>
     *                                                  <strong>Security Note:</strong><br>
     *                                                  It is the responsibility of the user of this component to sanitize the resolved {@code eventStreamTableName}'s value
     *                                                  to ensure the security of all the SQL statements generated by components using the {@link SeparateTablePerAggregateEventStreamConfiguration}, such as {@link SeparateTablePerAggregateTypePersistenceStrategy}.
     *                                                  The {@link SeparateTablePerAggregateEventStreamConfiguration} component will
     *                                                  call the {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} method to validate the table name as a first line of defense.<br>
     *                                                  However, {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} does not offer exhaustive protection, nor does it assure the complete security of the resulting SQL against SQL injection threats.<br>
     *                                                  <b>The responsibility for implementing protective measures against SQL Injection lies exclusively with the users/developers using the Essentials components and its supporting classes.</b><br>
     *                                                  Users must ensure thorough sanitization and validation of API input parameters,  column, table, and index names.<br>
     *                                                  Insufficient attention to these practices may leave the application vulnerable to SQL injection, potentially endangering the security and integrity of the database.<br>
     *                                                  <br>
     *                                                  It is highly recommended that the {@code eventStreamTableName}'s value is only derived from a controlled and trusted source.<br>
     *                                                  To mitigate the risk of SQL injection attacks, external or untrusted inputs should never directly provide the {@code eventStreamTableName}'s value.<br>
     *                                                  <b>Failure to adequately sanitize and validate this value could expose the application to SQL injection
     *                                                  vulnerabilities, compromising the security and integrity of the database.</b><br>
     * @param eventStreamTableColumnNames               Defines the names of the eventStreamTableColumnNames - The actual implementation must be compatible with the chosen {@link AggregateEventStreamPersistenceStrategy}<br>
     *                                                  <br>
     *                                                  <u><b>Security</b></u><br>
     *                                                  <br>
     *                                                  <b>All the column names provided</b> will be directly used in constructing SQL statements
     *                                                  through string concatenation, in components such as {@link SeparateTablePerAggregateTypePersistenceStrategy}, which exposes those components to SQL injection attacks.<br>
     *                                                  <br>
     *                                                  It is the responsibility of the user of this component to sanitize <b>all the column names provided</b>
     *                                                  to ensure the security of all the SQL statements generated by this component. The {@link SeparateTablePerAggregateEventStreamConfiguration} component will
     *                                                  call the {@link EventStreamTableColumnNames#validate()} method, which uses {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)}, to validate the column names provided as a first line of defense.<br>
     *                                                  The {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} provides an initial layer of defense against SQL injection by applying naming conventions intended to reduce the risk of malicious input.<br>
     *                                                  However, {@link PostgresqlUtil#checkIsValidTableOrColumnName(String)} does not offer exhaustive protection, nor does it assure the complete security of the resulting SQL against SQL injection threats.<br>
     *                                                  <b>The responsibility for implementing protective measures against SQL Injection lies exclusively with the users/developers using the Essentials components and its supporting classes.</b><br>
     *                                                  Users must ensure thorough sanitization and validation of API input parameters,  column, table, and index names.<br>
     *                                                  Insufficient attention to these practices may leave the application vulnerable to SQL injection, potentially endangering the security and integrity of the database.<br>
     *
     *                                                  <br>
     *                                                  It is highly recommended that <b>all the column names provided</b> are derived from a controlled and trusted source.<br>
     *                                                  To mitigate the risk of SQL injection attacks, external or untrusted inputs should never directly provide the column name values.<br>
     *                                                  <br>
     *                                                  <b>Failure to adequately sanitize and validate this value could expose the application to SQL injection
     *                                                  vulnerabilities, compromising the security and integrity of the database.</b>
     * @param jsonSerializer                            The {@link JSONEventSerializer}
     * @param identifierColumnTypeUsedForAllIdentifiers The SQL Column type used for all identifier columns (aggregate id, event id, correlation id, etc.)
     * @param jsonColumnTypeUsedForAllJSONColumns       The SQL JSON column type used for all JSON columns (Event and {@link EventMetaData})
     * @return the event stream configuration factory
     */
    public static SeparateTablePerAggregateTypeEventStreamConfigurationFactory standardConfiguration(Function<AggregateType, String> resolveEventStreamTableName,
                                                                                                     EventStreamTableColumnNames eventStreamTableColumnNames,
                                                                                                     JSONEventSerializer jsonSerializer,
                                                                                                     IdentifierColumnType identifierColumnTypeUsedForAllIdentifiers,
                                                                                                     JSONColumnType jsonColumnTypeUsedForAllJSONColumns,
                                                                                                     TenantSerializer<?> tenantSerializer) {
        return new SeparateTablePerAggregateTypeEventStreamConfigurationFactory(resolveEventStreamTableName,
                                                                                eventStreamTableColumnNames,
                                                                                100,
                                                                                jsonSerializer,
                                                                                identifierColumnTypeUsedForAllIdentifiers,
                                                                                identifierColumnTypeUsedForAllIdentifiers,
                                                                                identifierColumnTypeUsedForAllIdentifiers,
                                                                                jsonColumnTypeUsedForAllJSONColumns,
                                                                                jsonColumnTypeUsedForAllJSONColumns,
                                                                                tenantSerializer);
    }

    @Override
    public SeparateTablePerAggregateEventStreamConfiguration createEventStreamConfigurationFor(AggregateType aggregateType,
                                                                                               AggregateIdSerializer aggregateIdSerializer) {
        requireNonNull(aggregateType, "No aggregateType provided");
        return new SeparateTablePerAggregateEventStreamConfiguration(aggregateType,
                                                                     requireNonNull(resolveEventStreamTableName.apply(aggregateType), msg("Resolved EventStreamTableName for AggregateType '{}' was null", aggregateType)),
                                                                     eventStreamTableColumnNames,
                                                                     queryFetchSize,
                                                                     jsonSerializer,
                                                                     requireNonNull(aggregateIdSerializer, msg("The AggregateIdSerializer for AggregateType '{}' was null", aggregateType)),
                                                                     aggregateIdColumnType,
                                                                     eventIdColumnType,
                                                                     correlationIdColumnType,
                                                                     eventJsonColumnType,
                                                                     eventMetadataJsonColumnType,
                                                                     tenantSerializer);
    }
}
