# Essentials Components - PostgreSQL Durable Queues

The `DurableQueues` concept supports intra-service point-to-point messaging using durable Queues that guarantee At-Least-Once delivery of messages.  
The only requirement is that message producers and message consumers can access
the same underlying durable Queue storage.  
See [foundation](../foundation/README.md) for more information about how to use the `DurableQueues`

> **NOTE:**  
> **The library is WORK-IN-PROGRESS**

> Please see the **Security** notices below to familiarize yourself with the security risks

# Security
To support customization of storage table name, the `sharedQueueTableName` provided to the `PostgresqlDurableQueues` (either directly or via the `PostgresqlDurableQueues#builder()`),
will be directly used in constructing SQL statements through string concatenation, which exposes the component to **SQL injection attacks**.

It is the responsibility of the user of this component to sanitize the `sharedQueueTableName`
to ensure the security of all the SQL statements generated by this component.   
The `PostgresqlDurableQueues` component will
call the `PostgresqlUtil#checkIsValidTableOrColumnName(String)` method to validate the table name as a first line of defense.

The `PostgresqlUtil#checkIsValidTableOrColumnName(String)` provides an initial layer of defense against SQL injection by applying naming conventions intended to reduce the risk of malicious input.    
**However, Essentials components as well as `PostgresqlUtil#checkIsValidTableOrColumnName(String)` does not offer exhaustive protection, nor does it assure the complete security of the resulting SQL against SQL injection threats.**
> The responsibility for implementing protective measures against SQL Injection lies exclusively with the users/developers using the Essentials components and its supporting classes.
> Users must ensure thorough sanitization and validation of API input parameters,  column, table, and index names

**Insufficient attention to these practices may leave the application vulnerable to SQL injection, potentially endangering the security and integrity of the database.**

It is highly recommended that the `sharedQueueTableName` value is only derived from a controlled and trusted source.  
To mitigate the risk of SQL injection attacks, external or untrusted inputs should never directly provide the `sharedQueueTableName` value.  
Failure to adequately sanitize and validate this value could expose the application to SQL injection
vulnerabilities, compromising the security and integrity of the database.

# Configuration

To use `PostgreSQL Durable Queue` just add the following Maven dependency:

```xml
<dependency>
    <groupId>dk.cloudcreate.essentials.components</groupId>
    <artifactId>postgresql-queue</artifactId>
    <version>0.20.12</version>
</dependency>
```

Standalone example setting up `PostgresqlDurableQueues` (note: you can also use it together with either
the `EventStoreManagedUnitOfWorkFactory` or `SpringManagedUnitOfWorkFactory`):

```
var unitOfWorkFactory = new JdbiUnitOfWorkFactory(jdbi);
var durableQueues = new PostgresqlDurableQueues(unitOfWorkFactory);
durableQueues.start();
```

You need to decide on which `TransactionalMode` to run the `PostgresqlDurableQueues` in.

## SingleOperationTransaction

The recommended `TransactionalMode` is `SingleOperationTransaction`   
Running this mode is also useful for Long-running message handling and to ensure a Transaction failure doesn't affect re-queueing the failed message.
With `TransactionalMode` as `SingleOperationTransaction` where queueing and de-queueing are  performed using separate single document
transactions and where acknowledging/retry are also performed as separate transactions.

Depending on the type of errors that can occur this MAY leave a dequeued message
in a state of being marked as "being delivered" forever. Hence `PostgresqlDurableQueues` supports periodically
discovering messages that have been under delivery for a long time (aka. stuck messages or timed-out messages) and will
reset them in order for them to be redelivered.

Example `TransactionalMode#SingleOperationTransaction` Spring configuration:

```
@Bean
public DurableQueues durableQueues(HandleAwareUnitOfWorkFactory<? extends HandleAwareUnitOfWork> unitOfWorkFactory) {
    return new PostgresqlDurableQueues(unitOfWorkFactory,
                                       Duration.ofSeconds(10));
}
```

Using TransactionalMode#SingleOperationTransaction (if consuming messages manually without using `DurableQueues.consumeFromQueue(ConsumeFromQueue)`):

```
durableQueues.queueMessage(queueName, message);
var msgUnderDelivery = durableQueues.getNextMessageReadyForDelivery(queueName);
if (msgUnderDelivery.isPresent()) {
   try {
      handleMessage(msgUnderDelivery.get());
      durableQueues.acknowledgeMessageAsHandled(msgUnderDelivery.get().getId());
   } catch (Exception e) {
      durableQueues.retryMessage(msgUnderDelivery.get().getId(), 
                                 e,
                                 Duration.ofMillis(500));
   }
}
```

## FullyTransactional

Not recommended, since in this mode all the queueing, de-queueing methods requires an existing `UnitOfWork`
started prior to being called.
When changing an entity and queueing/de-queueing happens in ONE shared transaction *(NOTE this requires that the entity
storage and the queue storage  to use the same MongoDB database) then the shared database transaction guarantees that
all the data storage operations are committed or rollback as one, with the caveat that exceptions also affect the re-queueing the failed message

Example `TransactionalMode#FullyTransactional` Spring configuration:

```
@Bean
public DurableQueues durableQueues(HandleAwareUnitOfWorkFactory<? extends HandleAwareUnitOfWork> unitOfWorkFactory) {
    return new PostgresqlDurableQueues(unitOfWorkFactory);
}
```

## Typical Spring Beans required for setting up `PostgresqlDurableQueues`:

```
@Bean
public Jdbi jdbi(DataSource dataSource) {
    var jdbi = Jdbi.create(new TransactionAwareDataSourceProxy(dataSource));
    jdbi.installPlugin(new PostgresPlugin());
    return jdbi;
}

@Bean
public SpringTransactionAwareJdbiUnitOfWorkFactory unitOfWorkFactory(Jdbi jdbi,
                                                                     DataSourceTransactionManager transactionManager) {
    return new SpringTransactionAwareJdbiUnitOfWorkFactory(jdbi, transactionManager);
}

@Bean
public com.fasterxml.jackson.databind.Module essentialJacksonModule() {
    return new EssentialTypesJacksonModule();
}
```
