# Essentials Components - Postgresql Distributed Fenced Lock

This library provides a `FencedLockManager` implementation using Postgresql to coordinate intra-service distributed locks  
See [foundation](../foundation/README.md) for more information about how to use the `FencedLockManager`

> **NOTE:**  
> **The library is WORK-IN-PROGRESS**

> Please see the **Security** notices below to familiarize yourself with the security risks

# Security
To support customization of the database storage table name, you can specify a `fencedLocksTableName` parameter to the `PostgresqlFencedLockStorage` (either directly or via the `PostgresqlFencedLockManager#builder()`).   
The `fencedLocksTableName` value will be directly used in constructing SQL statements through string concatenation, which exposes the component to **SQL injection attacks**.

>It is the responsibility of the user of this component to sanitize the `fencedLocksTableName`
to ensure the security of all the SQL statements generated by this component.

The `PostgresqlFencedLockStorage` component will
call the `PostgresqlUtil#checkIsValidTableOrColumnName(String)` method to validate the table name as a first line of defense.  

The `PostgresqlUtil#checkIsValidTableOrColumnName(String)` provides an initial layer of defense against SQL injection by applying naming conventions intended to reduce the risk of malicious input.    
**However, Essentials components as well as `PostgresqlUtil#checkIsValidTableOrColumnName(String)` does not offer exhaustive protection, nor does it assure the complete security of the resulting SQL against SQL injection threats.**
> The responsibility for implementing protective measures against SQL Injection lies exclusively with the users/developers using the Essentials components and its supporting classes.
> Users must ensure thorough sanitization and validation of API input parameters,  column, table, and index names

**Insufficient attention to these practices may leave the application vulnerable to SQL injection, potentially endangering the security and integrity of the database.**

It is highly recommended that the `fencedLocksTableName` value is only derived from a controlled and trusted source.  
To mitigate the risk of SQL injection attacks, external or untrusted inputs should never directly provide the `fencedLocksTableName` value.  

**Failure to adequately sanitize and validate this value could expose the application to SQL injection
vulnerabilities, compromising the security and integrity of the database.**

# Configuration
To use `PostgreSQL Distributed Fenced Lock` just add the following Maven dependency:

```
<dependency>
    <groupId>dk.cloudcreate.essentials.components</groupId>
    <artifactId>postgresql-distributed-fenced-lock</artifactId>
    <version>0.40.24</version>
</dependency>
```

## Standalone configuration example:

```
var lockManager = PostgresqlFencedLockManager.builder()
                                      .setJdbi(Jdbi.create(jdbcUrl,
                                                           username,
                                                           password))
                                      .setUnitOfWorkFactory(unitOfWorkFactory)
                                      .setLockTimeOut(Duration.ofSeconds(3))
                                      .setLockConfirmationInterval(Duration.ofSeconds(1))
                                      .buildAndStart(); 
```

The `PostgresqlFencedLockManager#builder(...)` configures an instance of `PostgresqlFencedLockManager`, with a `PostgresqlFencedLockStorage` engine configured.

Note: The `PostgresqlFencedLockManager`, through the `PostgresqlFencedLockStorage`, supports overriding
the name of the table where the locks are stored. 
Per default locks are stored in `PostgresqlFencedLockStorage#DEFAULT_FENCED_LOCKS_TABLE_NAME`

## Spring Configuration example

```
@Bean
public FencedLockManager fencedLockManager(Jdbi jdbi, HandleAwareUnitOfWorkFactory<? extends HandleAwareUnitOfWork> unitOfWorkFactory) {
    return PostgresqlFencedLockManager.builder()
                                      .setJdbi(jdbi)
                                      .setUnitOfWorkFactory(unitOfWorkFactory)
                                      .setLockTimeOut(Duration.ofSeconds(3))
                                      .setLockConfirmationInterval(Duration.ofSeconds(1))
                                      .buildAndStart();
}
```



